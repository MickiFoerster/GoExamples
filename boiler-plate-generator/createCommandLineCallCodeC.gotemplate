#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>

int main(void) {
  int rc;
  int filedes[2];

  rc = pipe(filedes);
  if (rc == -1) {
    perror("pipe");
    exit(EXIT_FAILURE);
  }
  pid_t pid = fork();
	if (pid == -1 ) {
		perror("fork failed");
		exit(EXIT_FAILURE);
	} else if(pid == 0) { // child process
          const char path[] = "{{.Path}}";
          char *const args[] = {
          {{range $arg := .Args}} "{{$arg}}", {{end}}
            NULL
          };

          // Reroute stdout to pipe
          for (;;) {
            rc = dup2(filedes[1], STDOUT_FILENO);
            if (rc == -1) {
              if (errno == EINTR)
                continue;
              perror("dup2");
              exit(EXIT_FAILURE);
            }
            break;
          }
          close(filedes[0]); // close exit for child
          close(filedes[1]); // close entrance of pipe
          rc = execv(path, args);
          if (rc < 0) {
            fprintf(stderr, "execv failed: %s\n", strerror(errno));
          }
        } else { // parent
          close(filedes[1]); // close entrance of pipe in parent process
          // Now parent process reads from exit of pipe
          char buf[4096];
          waitpid(pid, NULL, 0);
          for (;;) {
            ssize_t n = read(filedes[0], buf, sizeof(buf));
            if (n == -1) {
              if (errno == EINTR || errno == EAGAIN) {
                continue;
              } else {
                perror("read");
                exit(EXIT_FAILURE);
              }
            } else if (n == 0) {
              break; // EOF
            } else {
              ssize_t i;
              fprintf(stderr, "catched from child process: ");
              for (i = 0; i < n; ++i) {
                if (buf[i] == '\n') {
                  fprintf(stderr, "\ncatched from child process: ");
                } else {
                  fprintf(stderr, "%c", buf[i]);
                }
              }
            }
          }
          close(filedes[0]); // close pipe exit for parent
        }

  return 0;
}

